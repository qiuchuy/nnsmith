import logging
import os
import random
import time

import numpy as np
import hydra
from omegaconf import DictConfig

from nnsmith.abstract.extension import activate_ext
from nnsmith.backends.factory import BackendFactory
from nnsmith.graph_gen import SymbolicGen, model_gen, viz
from nnsmith.logging import MGEN_LOG
from nnsmith.materialize import Model, TestCase
from nnsmith.materialize.c import CModel
from nnsmith.narrow_spec import auto_opset
from nnsmith.util import hijack_patch_requires, mkdir, op_filter


@hydra.main(version_base=None, config_path="../config", config_name="c_main")
def main(cfg: DictConfig):
    """Generate C neural network programs."""
    mgen_cfg = cfg["mgen"]

    seed = random.getrandbits(32) if mgen_cfg["seed"] is None else mgen_cfg["seed"]

    export_program_path = mgen_cfg["c_program_path"]

    MGEN_LOG.info(f"Using seed {seed}")

    # Model configuration - use C model type
    model_cfg = cfg["model"]
    ModelType = Model.init("c", backend_target=cfg["backend"]["target"])
    ModelType.add_seed_setter()

    # Backend configuration
    if cfg["backend"]["type"] is not None:
        factory = BackendFactory.init(
            cfg["backend"]["type"],
            target=cfg["backend"]["target"],
            optmax=cfg["backend"]["optmax"],
            parse_name=True,
        )
    else:
        factory = None

    # GENERATION
    opset = auto_opset(
        ModelType,
        factory,
        vulops=mgen_cfg["vulops"],
        grad=mgen_cfg["grad_check"],
    )
    opset = op_filter(opset, mgen_cfg["include"], mgen_cfg["exclude"])
    hijack_patch_requires(mgen_cfg["patch_requires"])
    activate_ext(opset=opset, factory=factory)

    tgen_begin = time.time()
    gen = model_gen(
        opset=opset,
        method=mgen_cfg["method"],
        seed=seed,
        max_elem_per_tensor=mgen_cfg["max_elem_per_tensor"],
        max_nodes=mgen_cfg["max_nodes"],
        timeout_ms=mgen_cfg["timeout_ms"],
        rank_choices=mgen_cfg["rank_choices"],
        dtype_choices=mgen_cfg["dtype_choices"],
    )
    tgen = time.time() - tgen_begin

    if isinstance(gen, SymbolicGen):
        MGEN_LOG.info(
            f"{len(gen.last_solution)} symbols and {len(gen.solver.assertions())} constraints."
        )

        if MGEN_LOG.getEffectiveLevel() <= logging.DEBUG:
            MGEN_LOG.debug("solution:" + ", ".join(map(str, gen.last_solution)))

    # MATERIALIZATION
    tmat_begin = time.time()
    ir = gen.make_concrete()

    MGEN_LOG.info(
        f"Generated DNN has {ir.n_var()} variables and {ir.n_compute_inst()} operators."
    )

    mkdir(mgen_cfg["save"])
    if cfg["debug"]["viz"]:
        fmt = cfg["debug"]["viz_fmt"].replace(".", "")
        viz(ir, os.path.join(mgen_cfg["save"], f"graph.{fmt}"))

    model = ModelType.from_gir(ir)
    model.refine_weights()
    model.set_grad_check(mgen_cfg["grad_check"])
    oracle = model.make_oracle()

    # Generate C code
    c_code = _generate_c_program(model, cfg)

    tmat = time.time() - tmat_begin

    # Save the test case
    tsave_begin = time.time()
    testcase = TestCase(model, oracle)
    testcase.dump(root_folder=mgen_cfg["save"])
    tsave = time.time() - tsave_begin

    MGEN_LOG.info(
        f"Time:  @Generation: {tgen:.2f}s  @Materialization: {tmat:.2f}s  @Save: {tsave:.2f}s"
    )

    # Write C program to file
    with open(export_program_path, "w") as f:
        f.write(c_code)

    MGEN_LOG.info(f"C program generated: {export_program_path}")

    # Also create a Makefile for easy compilation
    makefile_path = os.path.join(os.path.dirname(export_program_path), "Makefile")
    _generate_makefile(makefile_path, cfg)


def _generate_c_program(model: CModel, cfg: DictConfig) -> str:
    """Generate the complete C program."""

    c_parts = []

    # Header
    c_parts.append("""/*
 * Generated C Neural Network Program
 * Generated by NNSmith C Backend
 */
""")

    # Includes
    c_parts.extend(model.import_libs)
    c_parts.append("\n")

    # Model definitions
    c_parts.append(model.emit_def("model", "Model"))
    c_parts.append("\n")

    # Weight initialization
    c_parts.append(model.emit_weight("model"))
    c_parts.append("\n")

    # Input initialization
    c_parts.append(model.emit_input("test_input"))
    c_parts.append("\n")

    # Graph execution function
    graph_execution = model.emit_run("test_output", "model", "test_input")
    c_parts.append(graph_execution)
    c_parts.append("\n")

    # Main function
    main_code = _generate_main_function(model)
    c_parts.append(main_code)

    return "\n".join(c_parts)


def _generate_main_function(model: CModel) -> str:
    """Generate the main function for the C program."""

    num_inputs = len(model.input_like)
    num_outputs = len(model.output_like)

    main_code = f"""
int main() {{
    printf("C Neural Network Program (Raw Pointers)\\n");
    printf("======================================\\n\\n");

    // Initialize input data (using raw pointers)
    float* input_data[{num_inputs}];
    const int* input_shapes[{num_inputs}];
    int input_ndims[{num_inputs}];

    initialize_test_inputs(input_data, input_shapes, input_ndims);

    // Print input information
    printf("Input tensors:\\n");
"""

    # Add input printing
    for i, (name, tensor_spec) in enumerate(model.input_like.items()):
        shape_str = "x".join(map(str, tensor_spec.shape))
        size = np.prod(tensor_spec.shape)
        main_code += f"""
    printf("  Input {i} ({name}): shape=[{shape_str}], size={size}\\n");
"""

    main_code += f"""
    printf("\\n");

    // Initialize model weights
    initialize_model_weights();

    // Prepare output storage (using raw pointers)
    float* output_data[{num_outputs}];
    static int output_shape_arrays[{num_outputs}][4]; // Max 4D tensors
    const int* output_shapes[{num_outputs}];
    int output_ndims[{num_outputs}];

    // Set up output shapes
"""

    # Add output shape setup
    for i, (name, tensor_spec) in enumerate(model.output_like.items()):
        shape_str = ", ".join(map(str, tensor_spec.shape))
        ndims = len(tensor_spec.shape)
        main_code += f"""
    // Output {i}: {name}
    static int output_shape_{i}[] = {{{shape_str}}};
    output_shapes[{i}] = output_shape_{i};
    output_ndims[{i}] = {ndims};
"""

    main_code += f"""

    // Run the model
    printf("Running model inference...\\n");
    clock_t start = clock();

    run_model(input_data, input_shapes, input_ndims,
              output_data, output_shapes, output_ndims);

    clock_t end = clock();
    double elapsed_time = ((double)(end - start)) / CLOCKS_PER_SEC;

    printf("Inference completed in %.6f seconds\\n\\n", elapsed_time);

    // Print outputs
    printf("Model outputs:\\n");
"""

    # Add output printing
    for i, (name, tensor_spec) in enumerate(model.output_like.items()):
        size = np.prod(tensor_spec.shape)
        shape_str = "x".join(map(str, tensor_spec.shape))
        main_code += f"""
    printf("  Output {i} ({name}, shape: {shape_str}):\\n");
    printf("  [");
    for (int j = 0; j < {size}; j++) {{
        printf("%.6f", output_data[{i}][j]);
        if (j < {size} - 1) printf(", ");
        if ((j + 1) % 8 == 0) printf("\\n   ");
    }}
    printf("]\\n\\n");
"""

    # Print outputs to stdout
    main_code += """
    printf("\\n");

    // Clean up
    printf("Cleaning up memory...\\n");
    for (int i = 0; i < """
    main_code += f"{num_inputs}; i++) {{"
    main_code += """
        free(input_data[i]);
    }
    for (int i = 0; i < """
    main_code += f"{num_outputs}; i++) {{"
    main_code += """
        free(output_data[i]);
    }

    printf("Program completed successfully.\\n");
    return 0;
}
"""

    return main_code


def _generate_makefile(makefile_path: str, cfg: DictConfig):
    """Generate a Makefile for compiling the C program."""

    compiler = cfg.get("backend", {}).get("compiler", "gcc")
    opt_level = "-O2" if cfg.get("backend", {}).get("optmax", True) else "-O0"

    makefile_content = f"""# Makefile for generated C neural network program
# Generated by NNSmith C Backend

CC = {compiler}
CFLAGS = {opt_level} -Wall -std=c99 -lm
TARGET = neural_network

# Default target
all: $(TARGET)

# Build the neural network program
$(TARGET): model.c
\t$(CC) $(CFLAGS) -o $(TARGET) model.c

# Clean build artifacts
clean:
\trm -f $(TARGET) *.o

# Run with test data
run: $(TARGET)
\t./$(TARGET)

# Install dependencies (placeholder)
install:
\t@echo "No external dependencies required"

.PHONY: all clean run install
"""

    with open(makefile_path, "w") as f:
        f.write(makefile_content)


if __name__ == "__main__":
    main()